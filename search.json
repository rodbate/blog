                                                                                                                                                                                                                                                                                                                [{"title":"Spring Aware接口执行时机源码深度解读","url":"/blog/2020/03/11/Spring Aware接口执行时机源码深度解读/","content":"Spring Aware接口执行时机源码深度解读Spring中有这样一种标记接口的存在Aware,只要是spring管理的bean实现了Aware接口，那么spring就会在bean创建的某个时机将相应的资源注入到该spring bean中，比如ApplicationContextAware, 会将spring 应用上下文ApplicationContext自动注入到bean中。Spring内建的Aware接口Spring 内建的Aware大概分为以下几种Spring core 和 context的内建Aware接口ApplicationEventPublisherAwareMessageSourceAwareResourceLoaderAwareBeanFactoryAwareEnvironmentAwareEmbeddedValueResolverAwareImportAwareLoadTimeWeaverAwareBeanClassLoaderAwareBeanNameAwareApplicationContextAwareSpring web内建的Aware接口ServletContextAwareServletConfigAwareSpring其它内建Aware接口SchedulerContextAware (spring scheduling)NotificationPublisherAware  (spring jmx export)BootstrapContextAware (spring jca)如此多的Aware接口，还不包含定制以及第三方引用的(关于如何定制自己的Aware接口不在此探讨，会专门拿出一章来深究), 那么它们的执行时机和顺序是怎样的呢？在我们使用到多个Aware接口而且还需要注意其执行时机和顺序的时候，就必须要弄清楚这一块的逻辑。接下来就是本文重点，深入spring源码来考证探究其原理及发现总结其执行时机以及执行顺序的结论。Spring内建Aware接口的执行时机及顺序我们可以猜想到Aware接口的执行时机肯定是在Spring Bean创建的时候，那究竟具体在哪呢？接下来一起来探究一下。纵观Spring，对于Aware接口的执行实现主要有一下两种模式初始化Bean的时候直接进行方法调用 -&gt; setXXXXBeanPostProcessor -&gt; Object postProcessBeforeInitialization(Object bean, String beanName)结论：直接方法调用的时机要早于通过BeanPostProcessor#postProcessBeforeInitialization调用的时机接下来分析一下：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory由以上代码片段可以看出，在Spring初始化bean的阶段，首先是先调用执行invokeAwareMethods(beanName, bean), 然后再执行BeanPostProcessor#postProcessBeforeInitialization, 因此Aware接口执行顺序是 直接方法调用 &gt; 通过BeanPostProcessor#postProcessBeforeInitialization执行调用。下面来具体分析一下具体Aware接口的调用执行顺序。直接方法调用 -&gt; invokeAwareMethods(beanName, bean)由以上代码片段可以得出结论：Aware接口最先执行顺序是 BeanNameAware -&gt; BeanClassLoaderAware -&gt; BeanFactoryAware可以写段小代码验证一下。运行结果如下：因此可以验证上面的结论。BeanPostProcessor#postProcessBeforeInitialization第二种模式是通过BeanPostProcessor#postProcessBeforeInitialization的方式来调用相应的Aware接口核心代码片段如下所示：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory可以看到通过applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)来执行相应的Aware接口的BeanPostProcessor, 那么多个Aware接口的执行顺序就取决于相应的BeanPostProcessor的执行顺序。其中一个Spring内置的核心Aware BeanPostProcessor是ApplicationContextAwareProcessor, 可以看看这个processor关联的Aware接口invokeAwareInterfaces(bean);从以上代码可知ApplicationContextAwareProcessor关联了大部分Spring内置Aware接口,它们的执行顺序如下：EnvironmentAware -&gt; EmbeddedValueResolverAware -&gt; ResourceLoaderAware -&gt; ApplicationEventPublisherAware -&gt; MessageSourceAware -&gt; ApplicationContextAware验证代码示例由于篇幅原因就不贴了，文末会有代码地址，有需要可自行查看, 执行结果贴一下由于Aware的接口的调用受到BeanPostProcessor的直接影响，因此BeanPostProcessor的执行顺序也就是Aware接口的调用顺序。可以看看ApplicationContextAwareProcessor的设置执行时机。AbstractApplicationContext代码片段beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)这里可以看到ApplicationContextAwareProcessor直接第一个加入到该BeanFactory中。下面稍微看下BeanPostProcessor调用执行顺序(本文不作详细深究)BeanPostProcessor调用执行顺序回到上面的org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean代码片段中的由以上可知beanPostProcessors是关联该BeanFactory的有序列表, 这个列表的数据来源就是上文所提到的ConfigurableBeanFactory#addBeanPostProcessor(BeanPostProcessor beanPostProcessor) 这个方法。回到AbstractApplicationContext#refresh()中的注册BeanPostProcessor的最终执行者是PostProcessorRegistrationDelegate.registerBeanPostProcessors这其中的排序规则如下(针对于属于该BeanFactory的 BeanPostProcessor BeanDefinition): String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);实现了PriorityOrdered接口优先级最高, 再按order进行排序 小 -&gt; 大其次是实现了Ordered接口, 再按order进行排序 小 -&gt; 大其它的根据BeanDefinition Spring注册顺序来当然还可以通过BeanFactoryPostProcessor来配置该BeanFactory, 举个例子ConfigurationClassPostProcessor由以上可知ImportAware执行顺序ApplicationContextAwareProcessor关联的那些Aware接口之后执行。LoadTimeWeaverAwareProcessorAbstractApplicationContext#prepareBeanFactory目前的Aware接口执行顺序如下：BeanNameAware -&gt; BeanClassLoaderAware -&gt; BeanFactoryAware -&gt; EnvironmentAware -&gt; EmbeddedValueResolverAware -&gt; ResourceLoaderAware -&gt; ApplicationEventPublisherAware -&gt; MessageSourceAware -&gt; ApplicationContextAware -&gt; ImportAware -&gt; LoadTimeWeaverAware代码示例运行结果其它的Aware接口都可类似推研, 定制Aware接口也是类似方法, 简单提一下, 通过BeanPostProcessor来进行Aware接口设置调用。注: 本文示例代码地址 https://github.com/rodbate/blog-code/tree/master/java/springframework/src/main/java/com/github/rodbate/blogcode/springframework/aware","tags":["Spring","Java"]},{"title":"对象存储服务MinIO介绍","url":"/blog/2020/02/05/对象存储服务MinIO介绍/","content":"对象存储服务MinIOOpen Source, S3 Compatible, Enterprise Hardened and Really, Really FastMinIO是一种高性能并兼容Amazon S3 Api的对象存储服务官网地址  Github项目地址MinIO简介1. Erasure Coding(纠删码)MinIO数据存储数据保护数据采用的是Erasure Coding(纠删码)技术，与之对应人们熟知的是Replication(数据副本)技术, 两者之间的区别就不再赘述了。引用官方文档纠删码的应用解析MinIO protects data with per-object, inline erasure coding which is written in assembly code to deliver the highest performance possible. MinIO uses Reed-Solomon code to stripe objects into n/2 data and n/2 parity blocks - although these can be configured to any desired redundancy level. This means that in a 12 drive setup, an object is sharded across as 6 data and 6 parity blocks. Even if you lose as many as 5 ((n/2)–1) drives, be it parity or data, you can still reconstruct the data reliably from the remaining drives. MinIO’s implementation ensures that objects can be read or new objects written even if multiple devices are lost or unavailable. Finally, MinIO’s erasure code is at the object level and can heal one object at a time.说白了就是纠删码技术空间占用率低,容错率高。MinIO使用Reed-Solomon编码, 原始数据块=n/2, 校验数据块=n/2,一个对象条形存储在这些快上,容错率为(n/2 - 1)。MinIO服务部署 分布式部署适合生产场景分布式部署注意点：所有参与部署的节点都必须设置相同访问秘钥(即access key和secret key相同);MinIO以4, 6, 8, 10, 12, 14, 16的最大公约数创建EC数据集合(每个对象的存储MinIO采用不可逆的哈希算法分到相应的数据集中), 因此MinIO单个集群的硬盘数必须是4, 6, 8, 10, 12, 14, 16其中一个数的倍数;MinIO会选择最大的EC数据集合,比如8块硬盘,那么MinIO就会创建1个大小为8的EC数据集合;一个对象只会写到一个EC数据集合中, 也就是说一个对象不会存储超过16个硬盘;所有参与节点推荐为同构系统MinIO数据目录要求为独占MinIO节点之间的时间差异不能超过15分钟, 可以使用NTP时间同步设置环境变量MINIO_DOMAIN可以支持DNS风格的Bucket Federation模式引用官方示例单集群分布式部署示例MinIO分布式模式支持集群扩展多集群Federation模式Federation模式适用于MinIO多集群扩展, 在已有集群容量不够的情况下才会采取此模式进行扩展MinIO单集群是不支持动态扩缩容(增减节点或者硬盘数量)官方ISSUE 假设MinIO集群拥有四个节点, 每个节点拥有一块硬盘以上集群构成了一个EC数据集合的MinIO的服务集群。Nginx反向代理和负载均衡在生产分布式模式下, 可以采用nginx以获得以下能力HTTPS反向代理负载均衡限流…MinIO监控健康检查(Health Check)/minio/health/live  服务是否运行中/minio/health/ready  服务是否已就绪Promethus监控/minio/prometheus/metrics 指标Exported URL  详见官方文档MinIO API引用JAVA SDKBucket operations (Bucket操作)Object operations(对象操作)Presigned operations(预签名操作)Bucket Policy/LifeCycle Operations(Bucket权限及生命周期操作)makeBucketgetObjectpresignedGetObjectgetBucketPolicylistBucketsputObjectpresignedPutObjectsetBucketPolicybucketExistscopyObjectpresignedPostPolicysetBucketLifeCycleremoveBucketstatObjectgetBucketLifeCyclelistObjectsremoveObjectdeleteBucketLifeCyclelistIncompleteUploadsremoveIncompleteUploadlistenBucketNotificationcomposeObjectsetBucketNotificationselectObjectContentgetBucketNotificationremoveAllBucketNotificationenableVersioningdisableVersioningsetDefaultRetentiongetDefaultRetention常用的API一般就是对象操作API, 比如getObject: 下载对象putObject: 上传对象removeObject: 删除对象预签名(Presigned)操作的应用场景上传(presignedPutObject)或下载(presignedGetObject)时, 客户端可以向服务器获取对应的Presigned Url(预签名URL)的方式来完成操作。优点：MinIO秘钥统一由服务器管理, 客户端不需要也没必要管理获取的预签名URL是有时效性的，安全，时间长短可以由服务器设置详见官方文档介绍MinIO客户端秘钥收敛(STS模式)客户端访问MinIO的方式可以采用STS(Security Token Service)模式。类似下图三种角色IDP 身份校验服务Application 应用服务MinIO目前MinIO支持以下四种身份校验服务Client grantsWebIdentityAssumeRoleAD/LDAP","tags":["OSS","MinIO"]}]